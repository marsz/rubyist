<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rspec | 黃金俠]]></title>
  <link href="http://rubyist.marsz.tw/blog/categories/rspec/atom.xml" rel="self"/>
  <link href="http://rubyist.marsz.tw/"/>
  <updated>2012-02-24T02:32:11+08:00</updated>
  <id>http://rubyist.marsz.tw/</id>
  <author>
    <name><![CDATA[MarsZ]]></name>
    <email><![CDATA[marsz330@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用 resque 實作背景作業 (測試篇 - Rspec)]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-02-17/resque-spec/"/>
    <updated>2012-02-17T00:40:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-02-17/resque-spec</id>
    <content type="html"><![CDATA[<p>不管用什麼方式實作 background job 後<br/>
令人頭痛的是很難知道 worker 在執行工作時有沒有噴 exception<br/>
因此測試就顯得更為重要, 每次佈署前必須做好完整的測試, 以減少 worker 出錯<br/>
當然也可以搭配 Exceptional 或 Aribrake 之類的雲端服務來進行監控...</p>

<!-- more -->


<p>resque 的測試有專門的 gem, 用來在測試環境下模擬 message queue 和 worker</p>

<p>resque_spec : <a href="https://github.com/leshill/resque_spec" target="_blank">https://github.com/leshill/resque_spec</a></p>

<h4>安裝</h4>

<p><code>ruby Gemfile
group :test do
  gem 'resque_spec'
end
</code></p>

<p>這裡要注意一點, 不要在 development 環境下 bundle resque_spec, 即 Gemfile 中的 resque_spec 只能 group 在 test 下, 否則執行 Resque.enqueue 就不會送到 redis 而是送進 resque_spec 中</p>

<h4>使用</h4>

<p>resque_spec 的作法是讓原本丟工作到 mq 上的 Resque.enqueue 改為丟到 resque_spec 模擬的 mq 中<br/>
因此 Gemfile bundle 後, 就可以直接在 rspec 中使用, 以下將介紹 rspec 中常用的語法</p>

<h6>清空 mq 所有的 job</h6>

<p>```ruby
describe "#foo" do
  before do</p>

<pre><code>ResqueSpec.reset!
</code></pre>

<p>  end
end
```</p>

<h6>檢查某個 worker 的 job 數</h6>

<p><code>ruby
  FooWorker.should have_queue_size_of(2)
</code></p>

<h6>檢查某個 worker 的 queue 中應該要有的 job</h6>

<p><code>ruby
  FooWorker.should have_queued(foo.id, "bar")
</code></p>

<p>foo.id, "bar" 都是 enqueue 的參數</p>

<p><code>ruby
  # some where enqueue
  Resque.enqueue(FooWorker, foo.id, "bar")
</code></p>

<h6>立即執行不送 queue</h6>

<p>用 "with_resque"</p>

<p>```ruby
it "should works" do
  with_resque do</p>

<pre><code>@foo.run
</code></pre>

<p>  end
end
```</p>

<p>假設 run 的內容是</p>

<p><code>ruby
def run
  Resque.enqueue(FooWorker, id)
end
</code></p>

<p>在 with_resque 內, Resque.enqueue(FooWorker, id) 相當於 FooWorker.perform(id)</p>

<h6>執行 queue 裡面所有的 job</h6>

<p><code>ruby
it "should  works" do
  @foo.run
  ResqueSpec.perform_all(:queue_foo)
end
</code></p>

<p>"queue_foo" 是 Worker 中定義的 queue name</p>

<h4>整合 ResqueMailer</h4>

<p>gem "resque_mailer" 會將 mailer 中的 deliver 行為內容改為 Resque.enqueue<br/>
但是在 test 環境中, resque_mailer 則會還原 deliver 原本的行為<br/>
所以為了 rspec 中也可以測試 mailer 是否 enqueu, 要在 resque_mailer 中的 config 將原本排除掉的 test 環境加入 resque_mailer 的運作中</p>

<p><code>ruby  config/initializers/resque_mailer.rb
Resque::Mailer.excluded_environments = []
</code></p>

<hr />

<p>一般我們都會將複雜或吃效能的工作丟到背景執行<br/>
而複雜的工作又常常需要 debug<br/>
因此平常應該要養成寫 spec 的習慣<br/>
才不會讓自己跟這些複雜的功能過不去 :p</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Factory Girl 產生測試用資料]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-02-06/factory-girl-rails-intro/"/>
    <updated>2012-02-06T16:57:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-02-06/factory-girl-rails-intro</id>
    <content type="html"><![CDATA[<p>在寫測試的時候, 為了實際測試程式處理資料的正確性<br/>
免不了要依據資料庫的關聯建立假資料<br/>
但往往會因為 model 增加了一些 validation 而導致產生假資料的 code, 必須符合驗證而修改<br/>
當測試的量日漸龐大時, 改起來就會非常麻煩</p>

<!-- more -->


<p>factory_girl_rails 讓產生假資料的方式變得簡單和一致, 同時提昇 code 的可讀性<br/>
例如:</p>

<p><code>ruby
before do
  @user = User.create(:name =&gt; "foo", :email =&gt; "foo@bar.com", :state =&gt; :block)
end
</code></p>

<p>改用 factory_girl 後</p>

<p><code>ruby
before do
  @user = Factory :user_state_blocked
end
</code></p>

<h4>安裝</h4>

<p><code>ruby Gemfile
group :test, :development do
  gem "factory_girl_rails"
end
</code></p>

<p><code>ruby
bundle install
</code></p>

<h4>設定</h4>

<p>factory 的設定建議一個檔案對應一個 model, 放在 spec/factories 下<br/>
例如 app/models/user.rb => sepc/factiries/user.rb<br/>
為了讓 rails g model 的時候, 可以自動產生對應的 factory file, 可以加入以下 code 在 config/application.rb</p>

<p><code>ruby config/application.rb
config.generators do |g|
  g.test_framework :rspec, :fixture =&gt; true, :views =&gt; false, :fixture_replacement =&gt; :factory_girl
  g.fixture_replacement :factory_girl, :dir =&gt; "spec/factories"
end
</code></p>

<p>之後只要 "rails g model user" 也會自動產生 spec/factories/user.rb<br/>
內容如下</p>

<p><code>ruby spec/factories/user.rb
FactoryGirl.define do
  factory :user do
  end
end
</code></p>

<p>針對已經存在的 model 可以透過 -s 來略過已存在的檔案</p>

<p><code>ruby
rails g model user -s
</code></p>

<h4>定義與使用</h4>

<p>基本, factory 內的 method 對應 column name</p>

<p>```ruby spec/factories/user.rb
FactoryGirl.define do
  factory :user do</p>

<pre><code>name "foo"
email "bar@foo.com"
password "12341234"
birthday "1982-03-30"
</code></pre>

<p>  end
end
```</p>

<p>巢狀定義, 可用於某種 test case 下的資料內容, 下層的 column 內容會覆寫上層</p>

<p>```ruby spec/factories/user.rb
FactoryGirl.define do
  factory :user do</p>

<pre><code>name "foo"
email "bar@foo.com"
password "12341234"
birthday "1982-03-30"
state "actived"
factory :user_state_locked do
  state "locked"
  locked_at "2012-12-12"
end
factory :user_state_closed do
  state "closed"
  closed_at "2012-12-12 12:12:12"
end
</code></pre>

<p>  end
end
```</p>

<p><code>ruby spec/models/user_spec.rb
@user = Factory :user
@user_state_closed = Factory :user_state_closed
@user_state_locked = Factory :user_state_locked
</code></p>

<p>使用 factory 時, 也可以在後面的參數帶入自定欄位內容或關連</p>

<p><code>ruby spec/models/user_spec.rb
@user = Factory :user, :birthday =&gt; "1983-01-28"
@post = Factory :post, :user =&gt; @user
</code></p>

<p>下一篇將介紹更進階的 factory 定義!!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Spec (4) model validations 的 spec]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-02-04/rails-rspec-model-spec/"/>
    <updated>2012-02-04T16:45:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-02-04/rails-rspec-model-spec</id>
    <content type="html"><![CDATA[<p>本篇將介紹以最原始, 沒有用任何外掛下的 model validation spec 寫法<br/>
若覺得小弟有更好的寫法, 也歡迎不吝指教 :)</p>

<!-- more -->


<p>範例中所使用的 matchers:</p>

<p>be_valid<br/>
be_true<br/>
be_false</p>

<p>model檔: User</p>

<p><code>ruby
class User &lt; ActiveRecord::Base
  validates_presence_of :name
  validates_length_of :name, :in =&gt; 1..20
  validates_uniqueness_of :email
end
</code></p>

<p>spec 寫法 (spec/models/user_spec.rb)</p>

<p>```ruby
describe User do
  describe "validations" do</p>

<pre><code>before do
  @user = User.new :name =&gt; "foo", :email =&gt; "bar@foo.com"
end
it "should be valid" do
  @user.should be_valid
end
it "should not validate presence of :name" do
  @user.name = nil
  @user.should_not be_valid
end
it "should not validate length of :name" do
  @user.name = "foo" * 20
  @user.should_not be_valid
end
it "should not validate uniqueness of :email" do
  @user.save
  User.new(@user.attributes).should_not be_valid
end
</code></pre>

<p>  end
end
```</p>

<p>be_valid 可以讓 @user 先把 save 以前的 validation 都跑過, 並且預期 return true<br/>
當然若要直接 save 以預期結果的話, 可以改寫成</p>

<p><code>ruby
@user.save.should == true
@user.save.should == false
</code></p>

<p>或(可讀性較佳的寫法)</p>

<p><code>ruby
@user.save.should be_true
@user.save.should be_false
</code></p>

<p>謎之聲: 每個 validation 都要這樣寫好累 XD</p>

<p>當然上述的範例中除了麻煩之外, 當然 User 有追加了新的 validation 時, before 的 User.new 也要跟著對應, 倘若有很多需要 create user model 的 spec 時, 改起來就會很痛苦</p>

<p>因此上述的兩個 issue, 將會在下兩篇將會介紹透過 factory_girl_rails 和 shoulda-matchers 這兩個 gem 解決</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Rspec (3) pending 的使用]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-02-03/rails-rspec-pending/"/>
    <updated>2012-02-03T16:06:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-02-03/rails-rspec-pending</id>
    <content type="html"><![CDATA[<p>pending 的使用可先參考 <a href="https://github.com/dchelimsky/rspec/wiki/Pending-Examples" target="_blank">官方文件</a><br/>
一般 generator 產生的 spec 檔都會先幫你把 pending 加好</p>

<!-- more -->


<p><code>ruby
describe Foo do
  pending "add some examples to (or delete) #{__FILE__}"
end
</code></p>

<p>如此便可在你跑 spec 後, 顯示有幾個 pending 尚未實作</p>

<p><code>
1 example, 0 failures, 1 pending
</code></p>

<p>因為不是每個專案都會讓你有時間寫 spec<br/>
等到有時間寫的時候, 可能會因為累積了太多而不知該從何寫起<br/>
所以 pending 的功用可讓你在未來能透過 pending 的麵包屑回頭逐一把 spec 補上</p>

<p>因此無論再怎麼趕怎麼忙, 也必須先將 pending 寫上</p>

<p>pending 可分幾個層次如下...</p>

<h4>整個 class 的 pending</h4>

<p>用於 lib class 較多, 當然遇到超趕的時候 controller, model 也都會整個 pending ~ XD</p>

<p><code>ruby
describe FoosController do
  pending
end
</code></p>

<h4>某個 method 的 pending</h4>

<p>新加的 method, 或 method 改寫了, 原先的 spec 不敷使用</p>

<p>```ruby
describe Foo do
  describe "#bar" do</p>

<pre><code>pending
</code></pre>

<p>  end
end
```</p>

<p>或</p>

<p><code>ruby
describe Foo do
  pending "#bar"
end
</code></p>

<p>一般都是後者的寫法</p>

<h4>method/action 內的某個 case</h4>

<p>針對單一 method/action 寫測試, test case 數通常取決於有多少 if else 在裡頭, 當然遇到比較特殊的 method/action 時, 可能也會有幾個 test case 是為預期錯誤而做的</p>

<p>```ruby
describe Foo do
  describe "#bar" do</p>

<pre><code>it "should be a kind of Bar" do
  ....
end
pending "should raise error if bar_id is nil"
</code></pre>

<p>  end
end
```</p>

<p>另外, method 只針對 public methods 寫, 一般 protected 和 private method 都不寫 spec<br/>
嚴謹的專案, 對於 model 的 association, validation, callbacks, scope 也都會寫對應的 spec<br/>
我的習慣是, 在每次 commit 前檢查本此修改是否需要補 spec 或 pending, 補完後才一起 commit</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Rspec (2) 基本語法與執行]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-02-02/rails-rspec-basic-syntax/"/>
    <updated>2012-02-02T14:35:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-02-02/rails-rspec-basic-syntax</id>
    <content type="html"><![CDATA[<p>建議在開始本系列文以前先讀過, 以下參考文件與資源</p>

<!-- more -->


<p><a href="http://www.slideshare.net/ihower/rspec-7394497" target="_blank">ihower 投影片</a> - 必看!!!!!<br/>
<a href="http://rubydoc.info/gems/rspec-core/2.8.0/file/README.md#" target="_blank">Rspec-core Rdoc</a> - 架構必看!!!<br/>
<a href="https://github.com/rspec/rspec-rails" target="_blank">Rspec Rails</a> - 官方提供的簡單範例 for models, controllers, routes, helpers 等</p>

<h4>describe 與 it + should</h4>

<p>最簡單的 rspec 可由 describe 和 it 組成<br/>
it 裡面必須有 should (或其他 match 語法) 才會構成測試</p>

<p>小弟在初學 rspec 的時候, 大多透過 should == 和 should_not == 就吃遍天下了 :p<br/>
一般在初學 rspec 時, 需要多注意 describe 和 it 的階層關係, 才會讓你的 spec 可讀性較高</p>

<p>有規劃的 spec</p>

<p>```ruby
describe Foo do
  describe "#get_bar" do</p>

<pre><code>it "should be nil" do
  Foo.new.get_bar.should == nil
end
it "should be Bar" do
  Foo.first.get_bar.class.should == Bar
end
</code></pre>

<p>  end
```</p>

<p>沒有規劃的 spec</p>

<p>```ruby
describe Foo do
  it "#get_bar" do</p>

<pre><code>Foo.new.get_bar.should == nil # 當這行的測試沒過時, 下面的測試便不會再執行
Foo.first.get_bar.class.should == Bar
</code></pre>

<p>  end
end
```</p>

<p>盡可能讓每個 it 都是針對一種結果進行測試<br/>
描述中用 # 開頭的就表示是 method name</p>

<p>當漸漸學會其他的 match 語法時, 可讀性就去更高了
例如 <a href="http://apidock.com/rspec/Spec/Matchers/be_a_kind_of" target="_blank">be_a_kind_of</a> 可用於做 is_a_kind_of 的 match</p>

<p><code>ruby
Foo.first.get_bar.should be_a_kind_of(Bar)
</code></p>

<p>相當於</p>

<p><code>ruby
Foo.first.get_bar.class.should == Bar
</code></p>

<p>前者的可讀性是比較高的</p>

<h4>before 與 it</h4>

<p>before 必定是在某個 describe 下, 而 before 內的行為會在每個 it 以前執行<br/>
而善用 instance 變數, 可以將 before 產生的變數傳遞給底下每個 it 用</p>

<p>```ruby
describe Foo do
  before do</p>

<pre><code>@foo = Foo.create!
</code></pre>

<p>  end
  describe "#bar" do</p>

<pre><code>before do
  @bar = Bar.create!
  @foo.bar = @bar
  @foo.save
end
it "should be Bar" do
   @foo.bar.should be_a_kind_of(Bar) # 可以拿到 @foo
end
it "should be equeal to @bar" do
   @foo.bar.id.should == @bar.id # 也可以拿到 @bar
end
</code></pre>

<p>  end
  it "be a kind of Foo" do</p>

<pre><code>@foo.should be_a_kind_of(Foo) # 只能拿到 @foo
</code></pre>

<p>  end
end
```</p>

<p>此外每個 it 結束後, 都會將此 it (含 before) 內對 test db 的修改通通 rollback, 因此我們可視為每個 it 執行前 (before 前), test db 都會是空的</p>

<h4>執行測試</h4>

<p>必須注意:</p>

<ol>
<li>config/database.yml 必須要有 test env 的設定, 且 database 不能和 migrate 一樣</li>
<li>執行前若 development 有 migrations 沒跑的話, 必須先跑完</li>
</ol>


<p>跑 spec/ 下的所有測試</p>

<p><code>
bundle exec rake spec
</code></p>

<p>跑單一檔案的 spec</p>

<p><code>
bundle exec rspec spec/models/foo_spec.rb
</code></p>

<p>跑單一檔案時, 不會先重新 load db schema, 因此若有新的 migrations 在 development 跑過後, 必須先 rake spec 後才能跑單一檔案的 rspec</p>

<p>更多 rspec 指令的應用</p>

<p><code>
bundle exec rspec -h
</code></p>
]]></content>
  </entry>
  
</feed>
