<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rubygems | 黃金俠]]></title>
  <link href="http://rubyist.marsz.tw/blog/categories/rubygems/atom.xml" rel="self"/>
  <link href="http://rubyist.marsz.tw/"/>
  <updated>2012-02-23T19:38:01+08:00</updated>
  <id>http://rubyist.marsz.tw/</id>
  <author>
    <name><![CDATA[MarsZ]]></name>
    <email><![CDATA[marsz330@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用 resque 實作背景作業 (基本使用篇)]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-02-15/resque-basic-usage/"/>
    <updated>2012-02-15T15:36:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-02-15/resque-basic-usage</id>
    <content type="html"><![CDATA[<p>上篇提到如何進行 redis, resque, worker 的設定安裝
本篇將介紹基本使用方式</p>

<!-- more -->


<h4>參考連結</h4>

<p>RailsCast - 影片: <a href="http://railscasts.com/episodes/271-resque" target="_blank">Resque</a>
RailsCast - 文字: <a href="http://railscasts.com/episodes/271-resque?view=asciicast" target="_blank">
Resque</a>
官方文件: <a href="https://github.com/defunkt/resque" target="_blank">Github</a></p>

<h4>基本使用</h4>

<p>情境: 文章內容更新後, 要重新計算其價值(p幣~XD)</p>

<p>先寫好 worker 要做的事情, worker 可以是任何 class</p>

<p>```ruby app/workers/post_evaluate.rb
class PostEvaluate</p>

<p>  @queue = :post_evaluate</p>

<p>  def self.perform(post_id, total_time_seconds)</p>

<pre><code>evaluate Post.find(post_id), total_time_seconds
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>worker 必備兩個部分:
1. @queue 指定 queue 的名稱
2. class method: perform 執行 job 內容, 參數可自定</p>

<p>接下來是如何把 job 丟上 queue</p>

<p>```ruby app/models/post.rb
after_save :evaluate</p>

<p>def evaluate
  Resque.enqueue PostEvaluate, self.id, total_secs
end
```</p>

<p>Resque.enqueue [worker class], [argument 1], [argument 2], .....</p>

<p>相當於 worker 執行了 PostEvaluate.perform(self.id, total_secs)</p>

<h4>注意事項</h4>

<p>enqueue 的參數類型儘可能簡單: Fixnum, String, Array, Hash<br/>
不要將整個 model 或 class instance 丟到 mq 上<br/>
redis 無法儲存像 model 這樣複雜的變數類型</p>

<p>下一篇將介紹如何寫測試(Rspec)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 resque 實作背景作業 (前置設定篇)]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-02-13/resque-redis-and-worker-config/"/>
    <updated>2012-02-13T14:51:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-02-13/resque-redis-and-worker-config</id>
    <content type="html"><![CDATA[<p>resque 是一套可以用來實作 background job 的 gem<br/>
舉凡長時間的執行如 email, 點數計算等等非即時性的工作, 都可以採用非同步執行<br/>
以加速前端服務的反應速度<br/>
resque 是以 redis 做為 message queue server 的方式來進行...</p>

<!-- more -->


<h4>參考連結</h4>

<p>RailsCast - 影片: <a href="http://railscasts.com/episodes/271-resque" target="_blank">Resque</a><br/>
RailsCast - 文字: <a href="http://railscasts.com/episodes/271-resque?view=asciicast" target="_blank">Resque</a><br/>
官方文件: <a href="https://github.com/defunkt/resque" target="_blank">Github</a></p>

<h4>安裝 Gem</h4>

<p>```</p>

<h1>Gemfile</h1>

<p>gem "resque"
```</p>

<p><code>
bundle install
</code></p>

<h4>安裝 redis</h4>

<p>MacOS</p>

<p><code>
sudo brew install redis
</code></p>

<p>Debian / Ubuntu</p>

<p><code>
sudo apt-get install redis-server
</code></p>

<h4>啟動/停止 redis server</h4>

<p>MacOS</p>

<p>```</p>

<h1>啟動</h1>

<p>/usr/local/bin/redis-server /usr/local/etc/redis.conf</p>

<h1>停止 ps + kill :p</h1>

<p>sudo kill -SIGHUP $(ps aux|grep 'redis-server'|grep -v 'grep'|awk '{print $2}')
```</p>

<p>Debian / Ubuntu</p>

<p>```</p>

<h1>啟動</h1>

<p>sudo service redis-server start</p>

<h1>停止</h1>

<p>sudo service redis-server stop
```</p>

<h4>Resque 中的 redis 設定</h4>

<p>由於 resque 必須將 job 丟上 redis (mq server)<br/>
因此必須設定連線的位址</p>

<p>手動建立兩個檔案<br/>
config/redis.yml => redis 的連線設定檔<br/>
config/initializers/resque.rb => 初始化 resque</p>

<p><code>yml config/redis.yml
development:
  :redis: "localhost:6379"
</code></p>

<p><code>ruby config/initializers/resque.rb
config = YAML.load_file("#{Rails.root}/config/resque.yml")[Rails.env]
Resque.redis = config[:redis]
</code></p>

<h6>RedisToGo</h6>

<p>若是使用雲端的Redis服務-<a href="https://redistogo.com/" target="_blank">RedisToGo</a><br/>
可以直接在 yml 中貼上 instance 的 uri, 如</p>

<p><code>yml config/redis.yml
development:
  :redis: "redis://marsz:xxxxxx@stingfish.redistogo.com:9999"
</code></p>

<h6>redis-rb</h6>

<p>若 redis 有同時兼作 cache 或 db 用, 而且是透過 gem "redis" 進行連線的話<br/>
則可以直接將變數指定</p>

<p><code>yml config/redis.yml
development:
  :db: 0
  :host: "localhost"
  :port: 6379
</code></p>

<p><code>ruby config/initializers/resque.rb
config = YAML.load(File.open("#{Rails.root}/config/redis.yml"))[Rails.env]
Resque.redis = Redis.new( :host =&gt; config[:host], :port =&gt; config[:port], :db =&gt; config[:db] )
</code></p>

<p>一般小弟比較偏好最後一個方法, 因為 redis 太方便了, 只做 background job 有點可惜 XD</p>

<h4>Resque server</h4>

<p>想要有直觀的介面可以看目前 message queue (redis) 上的 job 執行狀況<br/>
resque 也有提供 :)</p>

<p>```ruby config/initializers/resque.rb</p>

<h1>在任何 initial 的檔案中加都可</h1>

<p>require "resque/server"
```</p>

<p><code>ruby config/routes.rb
mount Resque::Server.new, :at =&gt; "/admin/resque"  
</code></p>

<p>啟動 rails server, 連線 <a href="http://localhost:3000/admin/resque" target="_blank">http://localhost:3000/admin/resque</a> 就可以看到啦</p>

<h4>啟動 worker</h4>

<p>丟上 message queue 的工作, 必須透過 worker 逐個要下來執行<br/>
啟動worker...</p>

<p><code>ruby
QUEUE=* bundle exec rake resque:work
</code></p>

<p>上述指令啟動後就會掛著, 而 server 上的啟動可以透過 BACKGROUND=yes 讓 worker 變成背景執行, 之後會再介紹完整參數說明</p>

<p>worker 在 message queue 中有許多 issue, 例如:<br/>
1. 佈署時如何自動的重啟<br/>
2. server 上的 worker 掛了要怎麼自動重啟<br/>
3. worker 能否 multi-thread 執行或針對特定 queue 等等<br/>
將在後續會有相關 solution 的分享</p>

<hr />

<p>以上是有關 resque 的環境設定</p>

<p>redis => resuqe config => worker</p>

<p>下一篇將會介紹在 rails 中的基本使用方式</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Devise + Omniauth 的 Facebook 登入範例]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-02-11/devise-omniauth-for-facebook-login/"/>
    <updated>2012-02-11T01:20:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-02-11/devise-omniauth-for-facebook-login</id>
    <content type="html"><![CDATA[<p>以下範例應用於 rails 3.1.3 + devise 1.4.9 + oa-oauth 0.3.2<br/>
直接使用 devise 中的 omniauthable 有許多彈性不足的問題<br/>
因此小弟參考了網路上的作法, 加上因應某些需求的修改...</p>

<!-- more -->


<h4>參考</h4>

<p><a href="http://blog.railsrumble.com/blog/2010/10/08/intridea-omniauth" target="_blank">http://blog.railsrumble.com/blog/2010/10/08/intridea-omniauth</a></p>

<h4>步驟</h4>

<p>(以下範例以 user 做為 model 名稱)</p>

<p>安裝 gem</p>

<p><code>ruby
gem "devise", "1.4.9"
gem "oa-oauth", :require =&gt; "omniauth/oauth"
gem "oa-openid", :require =&gt; "omniauth/openid" # for google 或其他 openid auth
</code></p>

<p>devise initial setup</p>

<p><code>
rails g devise:install
rails g devise user
</code></p>

<p>在 users 的 migration 中, 依照需求可自行選擇加入</p>

<p>```ruby
create_table(:users) do |t|
  t.string :name # 儲存使用者名稱
  t.confirmable # email 認證, 若未來有提供註冊流程產生新使用者的可能性, 就加吧
  ...
end</p>

<p>change_column :users,:email, :string, :null => true # 若登入 open id 的 provider 不提供 email, 則必須做此設定, 讓 email 可以為 null
```</p>

<p>建立對應 opend id 和 user 的 model - authorization</p>

<p><code>
rails g model authorization provider:string uid:string user_id:integer
</code></p>

<p>user model 內容<br/>
1. devise 的 module 比預設的多了 confirmable, 主要為了提供未來也能使用站內註冊流程的可能<br/>
2. create_from_auth 處理 omniauth 丟過來的 auth_hash 並且以 email 為 unique key 新增 user</p>

<p>```ruby app/models/user.rb
class User &lt; ActiveRecord::Base
  devise :database_authenticatable, :registerable,</p>

<pre><code>     :recoverable, :rememberable, :trackable, :validatable,
     :confirmable # 加上 confirmable
</code></pre>

<p>  has_many :authorizations</p>

<p>  def self.create_from_auth!(hash)</p>

<pre><code>created_hash = {:email =&gt; hash[:user_info][:email], :name =&gt; hash[:user_info][:name] }
user = (created_hash[:email].nil? ? nil : User.find_by_email(created_hash[:email])) || User.new(created_hash)
if user.email
  user.confirm!
elsif user
  user.save!
end
user
</code></pre>

<p>  end
end
```</p>

<p>authorization model 內容<br/>
1. 對應 user 和 open id, 使其不重複<br/>
2. #create_by_omniauth 處理從 omniauth 登入後的資料, 可以將 provider 的資料整合進指定的user(例如目前登入者) 或相同 email 的 user<br/>
3. constant PROVIDERS 用以提供未來擴充 provider 的彈性</p>

<p>```ruby
class Authorization &lt; ActiveRecord::Base
  PROVIDERS = [:facebook]</p>

<p>  belongs_to :user
  validates_presence_of :user_id, :uid, :provider
  validates_uniqueness_of :uid, :scope => :provider</p>

<p>  def self.create_by_omniauth(hash, current_user = nil)</p>

<pre><code>hash = ActiveSupport::HashWithIndifferentAccess.new hash
auth = find_from_hash(hash)
unless auth
  current_user ||= User.create_from_auth!(hash)
  auth = Authorization.new(:user=&gt;current_user,:uid=&gt;hash[:uid],:provider=&gt;hash[:provider])
  auth.save
end
auth
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def self.find_from_hash(hash)</p>

<pre><code>if hash[:provider] &amp;&amp; hash[:uid]
  find_by_provider_and_uid(hash[:provider],hash[:uid])
end
</code></pre>

<p>  end
end
```</p>

<p>設定 omniauth (facebook 登入的 app data), 同時讓 /auth/facebook 的 route 可以連接 fb 的 oauth, 相關可參考 <a href="https://github.com/intridea/omniauth" target="_blank">omniauth 的說明</a></p>

<p><code>ruby config/initializers/omniauth.rb
Rails.application.config.middleware.use OmniAuth::Builder do
  config = YAML.load(File.open("#{Rails.root}/config/omniauth.yml"))[Rails.env]
  provider :facebook, config[:facebook][:api_id], config[:facebook][:api_secret]
end
</code></p>

<p>```yml config/omniauth.yml
development:
  :facebook:</p>

<pre><code>:domain: "foo.com"
:api_id: "12341234"
:api_secret: "barbarbarbar"
</code></pre>

<p>test:
  :facebook:</p>

<pre><code>:domain: "foo.com"
:api_id: "12341234"
:api_secret: "barbarbarbar"
</code></pre>

<p>production:
  :facebook:</p>

<pre><code>:domain: "foo.com"
:api_id: "12341234"
:api_secret: "barbarbarbar"
</code></pre>

<p>```</p>

<p>如同 omniauth 的做法, 把接 facebook (或其他 provider) 的 route 和 controller 寫好</p>

<p><code>ruby
rails g controller sessions
</code></p>

<p>有可能登入 facebook 會 fail, 所以也要把 fail 的部份寫好</p>

<p>```ruby app/controllers/sessions_controller.rb
class SessionsController &lt; ApplicationController
  def create</p>

<pre><code>@auth = Authorization.create_by_omniauth(auth_hash, current_user)
if @auth.user
   sign_in_and_redirect :user, @auth.user
else
  raise do
    logger.info "auth_hash: #{auth_hash.inspect}"
    logger.info "@auth: #{@auth.errors.inspect}"
    redirect_to new_user_session_path
  end
end  
</code></pre>

<p>  end</p>

<p>  def failure</p>

<pre><code>flash[:error] = params[:message]
redirect_to new_user_session_path
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def auth_hash</p>

<pre><code>request.env['omniauth.auth']
</code></pre>

<p>  end
end
```</p>

<p>設定 route, 包含 omniauth 和 devise</p>

<p>```ruby config/routes.rb
  match '/auth/:provider/callback', :to => 'sessions#create'
  match '/auth/failure' => 'sessions#failure'
  devise_for :users do</p>

<pre><code>get '/users/sign_in', :to =&gt; 'devise/sessions#new', :as =&gt; :new_user_session
get '/users/sign_out' =&gt; 'devise/sessions#destroy', :as =&gt; :user_sign_out
</code></pre>

<p>  end
```</p>

<p>view 裡面的 Facebook 登入按鈕 (html)</p>

<p><code>html
&lt;a href="http://rubyist.marsz.tw/auth/facebook"&gt;Facebook 登入&lt;/a&gt;
</code></p>

<p>若希望 Facebook 登入後可以導回登入前的頁面, 則可以做以下設定<br/>
主要參考 <a href="https://github.com/plataformatec/devise/wiki/How-To:-Redirect-to-a-specific-page-on-successful-sign-in" target="_blank">Devise Wiki</a></p>

<p>```ruby app/controllers/application_controller.rb
class ApplicationController &lt; ActionController::Base
  private</p>

<p>  def after_sign_in_path_for(user)</p>

<pre><code>request.env['omniauth.origin'] || stored_location_for(user) || users_path(user)
</code></pre>

<p>  end
end
```</p>

<p>目前沒有使用 devise 1.5 以上的原因是在這裡會遇到 redirect loop 的問題</p>

<h4>結論</h4>

<p>本篇範例主要以最常用的 facebook 登入為主<br/>
另外也提供了整合 openid 至現有帳號的功能<br/>
大多數的使用者帳號系統最在意的是能否拿到 email, 雖然 Facebook 是最多人使用的 open id, 但是基於網站本身的內容特性, 提供網站自己的註冊流程也是必要的<br/>
接下來還有另一篇介紹上述範例中的 rspec 會怎麼寫</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Factory Girl 產生測試用資料]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-02-06/factory-girl-rails-intro/"/>
    <updated>2012-02-06T16:57:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-02-06/factory-girl-rails-intro</id>
    <content type="html"><![CDATA[<p>在寫測試的時候, 為了實際測試程式處理資料的正確性<br/>
免不了要依據資料庫的關聯建立假資料<br/>
但往往會因為 model 增加了一些 validation 而導致產生假資料的 code, 必須符合驗證而修改<br/>
當測試的量日漸龐大時, 改起來就會非常麻煩</p>

<!-- more -->


<p>factory_girl_rails 讓產生假資料的方式變得簡單和一致, 同時提昇 code 的可讀性<br/>
例如:</p>

<p><code>ruby
before do
  @user = User.create(:name =&gt; "foo", :email =&gt; "foo@bar.com", :state =&gt; :block)
end
</code></p>

<p>改用 factory_girl 後</p>

<p><code>ruby
before do
  @user = Factory :user_state_blocked
end
</code></p>

<h4>安裝</h4>

<p><code>ruby Gemfile
group :test, :development do
  gem "factory_girl_rails"
end
</code></p>

<p><code>ruby
bundle install
</code></p>

<h4>設定</h4>

<p>factory 的設定建議一個檔案對應一個 model, 放在 spec/factories 下<br/>
例如 app/models/user.rb => sepc/factiries/user.rb<br/>
為了讓 rails g model 的時候, 可以自動產生對應的 factory file, 可以加入以下 code 在 config/application.rb</p>

<p><code>ruby config/application.rb
config.generators do |g|
  g.test_framework :rspec, :fixture =&gt; true, :views =&gt; false, :fixture_replacement =&gt; :factory_girl
  g.fixture_replacement :factory_girl, :dir =&gt; "spec/factories"
end
</code></p>

<p>之後只要 "rails g model user" 也會自動產生 spec/factories/user.rb<br/>
內容如下</p>

<p><code>ruby spec/factories/user.rb
FactoryGirl.define do
  factory :user do
  end
end
</code></p>

<p>針對已經存在的 model 可以透過 -s 來略過已存在的檔案</p>

<p><code>ruby
rails g model user -s
</code></p>

<h4>定義與使用</h4>

<p>基本, factory 內的 method 對應 column name</p>

<p>```ruby spec/factories/user.rb
FactoryGirl.define do
  factory :user do</p>

<pre><code>name "foo"
email "bar@foo.com"
password "12341234"
birthday "1982-03-30"
</code></pre>

<p>  end
end
```</p>

<p>巢狀定義, 可用於某種 test case 下的資料內容, 下層的 column 內容會覆寫上層</p>

<p>```ruby spec/factories/user.rb
FactoryGirl.define do
  factory :user do</p>

<pre><code>name "foo"
email "bar@foo.com"
password "12341234"
birthday "1982-03-30"
state "actived"
factory :user_state_locked do
  state "locked"
  locked_at "2012-12-12"
end
factory :user_state_closed do
  state "closed"
  closed_at "2012-12-12 12:12:12"
end
</code></pre>

<p>  end
end
```</p>

<p><code>ruby spec/models/user_spec.rb
@user = Factory :user
@user_state_closed = Factory :user_state_closed
@user_state_locked = Factory :user_state_locked
</code></p>

<p>使用 factory 時, 也可以在後面的參數帶入自定欄位內容或關連</p>

<p><code>ruby spec/models/user_spec.rb
@user = Factory :user, :birthday =&gt; "1983-01-28"
@post = Factory :post, :user =&gt; @user
</code></p>

<p>下一篇將介紹更進階的 factory 定義!!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Spec (4) model validations 的 spec]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-02-04/rails-rspec-model-spec/"/>
    <updated>2012-02-04T16:45:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-02-04/rails-rspec-model-spec</id>
    <content type="html"><![CDATA[<p>本篇將介紹以最原始, 沒有用任何外掛下的 model validation spec 寫法<br/>
若覺得小弟有更好的寫法, 也歡迎不吝指教 :)</p>

<!-- more -->


<p>範例中所使用的 matchers:</p>

<p>be_valid<br/>
be_true<br/>
be_false</p>

<p>model檔: User</p>

<p><code>ruby
class User &lt; ActiveRecord::Base
  validates_presence_of :name
  validates_length_of :name, :in =&gt; 1..20
  validates_uniqueness_of :email
end
</code></p>

<p>spec 寫法 (spec/models/user_spec.rb)</p>

<p>```ruby
describe User do
  describe "validations" do</p>

<pre><code>before do
  @user = User.new :name =&gt; "foo", :email =&gt; "bar@foo.com"
end
it "should be valid" do
  @user.should be_valid
end
it "should not validate presence of :name" do
  @user.name = nil
  @user.should_not be_valid
end
it "should not validate length of :name" do
  @user.name = "foo" * 20
  @user.should_not be_valid
end
it "should not validate uniqueness of :email" do
  @user.save
  User.new(@user.attributes).should_not be_valid
end
</code></pre>

<p>  end
end
```</p>

<p>be_valid 可以讓 @user 先把 save 以前的 validation 都跑過, 並且預期 return true<br/>
當然若要直接 save 以預期結果的話, 可以改寫成</p>

<p><code>ruby
@user.save.should == true
@user.save.should == false
</code></p>

<p>或(可讀性較佳的寫法)</p>

<p><code>ruby
@user.save.should be_true
@user.save.should be_false
</code></p>

<p>謎之聲: 每個 validation 都要這樣寫好累 XD</p>

<p>當然上述的範例中除了麻煩之外, 當然 User 有追加了新的 validation 時, before 的 User.new 也要跟著對應, 倘若有很多需要 create user model 的 spec 時, 改起來就會很痛苦</p>

<p>因此上述的兩個 issue, 將會在下兩篇將會介紹透過 factory_girl_rails 和 shoulda-matchers 這兩個 gem 解決</p>
]]></content>
  </entry>
  
</feed>
