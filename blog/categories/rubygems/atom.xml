<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rubygems | 黃金俠]]></title>
  <link href="http://rubyist.marsz.tw/blog/categories/rubygems/atom.xml" rel="self"/>
  <link href="http://rubyist.marsz.tw/"/>
  <updated>2012-03-17T11:14:24+08:00</updated>
  <id>http://rubyist.marsz.tw/</id>
  <author>
    <name><![CDATA[MarsZ]]></name>
    <email><![CDATA[marsz330@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rspec 設定 request 或 controller 的 spec 中 render view]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-03-06/rspec-render-views/"/>
    <updated>2012-03-06T11:05:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-03-06/rspec-render-views</id>
    <content type="html"><![CDATA[<p><code>rspec rails</code> 中預設是不會 render view 的, 因此 <code>response.body</code> 的內容會是空字串</p>

<!-- more -->


<p>為了讓 response.body 能實際的把 view render 出來, 可以有個別或預設的作法</p>

<p>個別</p>

<p>```ruby
describe UsersController do
  render_views
  it "GET #index" do</p>

<pre><code>get :index
response.body.should match("foo")
</code></pre>

<p>  end
end
```</p>

<p>預設</p>

<p><code>ruby spec/spec_helper.rb
RSpec.configure do |config|
  ....
  config.render_views
  ....
end
</code></p>

<p>小弟個人較偏好每個 request / controller 的 spec 都要 render_view<br/>
一方面可以檢驗 view 的正確性<br/>
若 view 中有使用 helper method, 也可以順便檢驗</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Factory Girl 的回呼 (callbacks)]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-02-29/factory-girl-callbacks/"/>
    <updated>2012-02-29T10:18:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-02-29/factory-girl-callbacks</id>
    <content type="html"><![CDATA[<p>在寫測試中, 有許多的情境, 可能會需要在產生測試用資料後做許多處理, 因此 <code>Factory Girl</code> 本身也提供了 <code>callback</code> 機制...</p>

<!-- more -->


<p>```ruby
FactoryGirl.define do
  factory :user do</p>

<pre><code>sequence(:email) { |n| "foo#{n}@bar.com" }
name "barbar"
password "12341234"
after_create do |user|
  # callback code block here
end
</code></pre>

<p>  end
end
```</p>

<p>詳細使用方式可見 <a href="https://github.com/thoughtbot/factory_girl/blob/master/GETTING_STARTED.md" target="_blank">官方說明文件</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[factory_girl 中的 model 關連 (association)]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-02-27/factory-girl-for-associations/"/>
    <updated>2012-02-27T09:42:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-02-27/factory-girl-for-associations</id>
    <content type="html"><![CDATA[<p>不論是 <code>one-to-one</code> <code>one-to-many</code> 或 <code>many-to-many</code>, 我們都希望 model 中的關連也能反應到 <code>factory_girl</code> 的定義中</p>

<!-- more -->


<p>方法如下:  (brand has many products)</p>

<p>```ruby spec/factories/brands.rb
FactoryGirl.define do
  factory :brand do</p>

<pre><code>sequence(:name) { |n| "brand name #{n}" }
</code></pre>

<p>  end
end
```</p>

<p>```ruby spec/factories/products.rb
FactoryGirl.define do
  factory :products do</p>

<pre><code>name "product name"
brand do
  Factory :brand
end
</code></pre>

<p>  end
end
```</p>

<p><code>ruby app/models/product.rb
class Product &lt; ActiveRecord::Base
  belongs_to :brand  # brand_id
end
</code></p>

<p>如此只要每次 <code>Factory(:product)</code> , 該 product 的 brancd 也會透過 brancd 產生, 而不需要再每次的 factory 中去進行關連了 <code>Factory(:product, :brand =&gt; Factory(:brand))</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[factory_girl 的 validates_uniqueness_of 欄位問題]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-02-25/factory-girl-for-uniqueness-column/"/>
    <updated>2012-02-25T09:25:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-02-25/factory-girl-for-uniqueness-column</id>
    <content type="html"><![CDATA[<p><code>model</code> 中有 <code>validates_uniqueness_of</code> 的欄位, 在 <code>factory_girl</code> 中可透過 <code>sequence</code> 來避免兩次以上的 factory 因 validation 沒過而無法產生假資料的情況</p>

<!-- more -->


<p>```ruby spec/factories/users.rb
FactoryGirl.define do
  factory :user do</p>

<pre><code>sequence(:email) do |n|
  "foo#{n}@bar.com"
end
name "barbar"
password "12341234"
</code></pre>

<p>  end
end
```</p>

<p><code>n</code> 為流水號, 因此可用於 <code>number</code> 或 <code>string</code> 類型的 column</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 resque 實作背景作業 ( 佈署篇)]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-02-21/resque-deploy-worker/"/>
    <updated>2012-02-21T01:56:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-02-21/resque-deploy-worker</id>
    <content type="html"><![CDATA[<p>透過 capistrano 佈署到 server 時，除了需要啟動 worker 之外，也會希望在每次佈署後，也重新啟動 worker<br/>
因為 worker 是透過 rake 啟動的，所以當 perform 相關的程式有修改時，worker 也必須重新啟動<br/>
以下將介紹如何將重啟 worker 整合到 capistrano 中</p>

<!-- more -->


<h4>將 worker 丟背景執行的方法</h4>

<p>resque 1.9 以上有提供參數 :)</p>

<p><code>
BACKGROUND=yes QUEUE=foo_queue bundle exec rake environment resque:work
</code></p>

<p>背景的 worker 要留一下 pid file, 以方便 kill</p>

<p><code>
PIDFILE=./resque.pid BACKGROUND=yes QUEUE=foo_queue bundle exec rake environment resque:work
</code></p>

<h4>整合 capistrano</h4>

<p>deploy 中加 restart_resque 的 task</p>

<p>```ruby config/deploy.rb
namespace :deploy do
  # .....
  task :restart_resque, :roles => :app do</p>

<pre><code>queues = [:foo_queue, :barbar]
queues.each do |queue|
  pid_file = "#{current_path}/tmp/pids/resque-#{queue}.pid"    
  run "test -f #{pid_file} &amp;&amp; cd #{current_path} &amp;&amp; kill -s QUIT `cat #{pid_file}` || rm -f #{pid_file}"
  run "cd #{current_path} &amp;&amp; PIDFILE=#{pid_file} RAILS_ENV=#{rails_env} BACKGROUND=yes QUEUE=#{queue} bundle exec rake environment resque:work"
end
</code></pre>

<p>  end
  #...
end
```</p>

<p>上面的例子是以一條 queue 配一個 worker 的方式執行，若要通通塞一個 worker 就 QUEUE=* 吧 XD</p>

<p>restart app 後就 restart resque worker 吧!!</p>

<p><code>ruby config/deploy.rb
after 'deploy:restart', 'deploy:restart_resque'
</code></p>

<h4>有關啟動 worker 的參數</h4>

<p>resque 提供了許多參數，讓你可以依照不同的需求執行worker，底下將介紹</p>

<h6>將 worker 執行的結果輸出</h6>

<p>debug 很好用，但個人還是推薦用 rspec 去 debug 吧 XD</p>

<p><code>ruby
VVERBOSE=1 QUEUE=* bundle exec rake environment resque:work
</code></p>

<h6>指定 queue (一條或多條)</h6>

<p>多條可以逗號隔開</p>

<p><code>ruby
QUEUES=file_serve,warm_cache bundle exec rake environment resque:work
</code></p>

<p>* 則是所有的 queue</p>

<p><code>ruby
QUEUES=* bundle exec rake environment resque:work
</code></p>

<h6>polling 的頻率</h6>

<p>針對即時性高的需求,以秒計,預設為 5 秒</p>

<p><code>
INTERVAL=0.1 QUEUE=foo bundle exec rake environment resque:work
</code></p>

<h6>多個 worker 同步執行</h6>

<p><code>
COUNT=5 QUEUE=* bundle exec rake environment resque:workers
</code></p>

<p>但官方推薦用 gem "god" 來執行多個 worker<br/>
相關可參考 <a href="https://github.com/defunkt/resque/blob/master/examples/god/resque.god" target="_blank">官方範例</a><br/>
god 也可以用來解決 worker 掛掉的問題<br/>
有關 god 的整合, 有空再分享 :p</p>
]]></content>
  </entry>
  
</feed>
