<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[categories: Rubygems | 黃金俠]]></title>
  <link href="http://rubyist.marsz.tw/blog/categories/rubygems/atom.xml" rel="self"/>
  <link href="http://rubyist.marsz.tw/"/>
  <updated>2012-08-12T14:35:37+08:00</updated>
  <id>http://rubyist.marsz.tw/</id>
  <author>
    <name><![CDATA[MarsZ]]></name>
    <email><![CDATA[marsz330@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[omniauth 登入後的 redirect 設定]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-08-10/omniauth-redirect-after-login/"/>
    <updated>2012-08-10T14:08:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-08-10/omniauth-redirect-after-login</id>
    <content type="html"><![CDATA[<p>我們曾在 <a href="http://rubyist.marsz.tw/blog/2012-01-10/callbacks-of-devise-after-sign-in-or-sign-out/">Devise callbacks</a> 中，描述如何在登入後自定 redirect。這次則是在 omniauth 進行 open id 驗證時就先把 redirect 當參數先丟。</p>

<!-- more -->


<p>參考 <a href="https://github.com/intridea/omniauth/issues/218">官方作法</a><br/>
利用 <code>origin</code> 參數即可在 open id 驗證後進行 redirect</p>

<p><code>ruby config/routes.rb
match '/auth/facebook', :as =&gt; :facebook_login
</code></p>

<p>```ruby app/views/xxx.erb</p>

<h1>view 或 controller 下</h1>

<p>facebook_login_path(:origin => "/url/for/redirect")</p>

<h1>即 "/auth/facebook?origin=/url/for/redirect"</h1>

<p>```</p>

<p>若 <code>devise</code> 中已經透過 application_controller.rb 的 <code>after_sign_in_path_for</code> 處理登入後的 redirect 時，則可以透過 <code>request.env['omniauth.origin']</code> 取得 origin 參數的內容。</p>

<p><code>ruby app/controllers/application_controller.rb
def after_sign_in_path_for(user)
  return request.env['omniauth.origin'] || root_path
end
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[devise 的 user 登入免驗證密碼]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-08-09/devise-user-without-validate_password/"/>
    <updated>2012-08-09T17:15:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-08-09/devise-user-without-validate_password</id>
    <content type="html"><![CDATA[<p><code>Devise</code> 加上 <code>Omniauth</code> (或其他 Open ID 登入機制) 時，資料庫的密碼欄位可能會需要為空值，因此可在 user 的 model 中覆寫 <code>password_required?</code> (為 public method) 即可。</p>

<!-- more -->


<p>```ruby app/models/user.rb
  def password_required?</p>

<pre><code>return (self.facebook_id ? false : true)
</code></pre>

<p>  end
```</p>

<p>該範例之邏輯為，有 facebook id 時密碼欄位可為空值。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 backup gem 做自動化備份]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-03-08/backup-gem/"/>
    <updated>2012-03-08T11:57:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-03-08/backup-gem</id>
    <content type="html"><![CDATA[<p>source: <a href="https://github.com/meskyanichi/backup" target="_blank">https://github.com/meskyanichi/backup</a><br/>
和 <a href="http://godrb.com/" target="_blank">God</a> 一樣是一個獨立的 gem，因此也可用於其他語言</p>

<!-- more -->


<p><code>backup</code> 的特色:</p>

<ol>
<li>可備份 <code>Redis</code>、<code>MongoDB</code>、<code>Mysql</code> 等 DB</li>
<li>可備份檔案、目錄</li>
<li>備份可儲存於 local disk、<code>Amazon S3</code>、<code>Dropbox</code> 或透過 <code>ftp</code>.<code>scp</code> 等協定將檔案上傳</li>
</ol>


<p>範例檔的備份標的:</p>

<ol>
<li><code>Mysql</code></li>
<li>使用者上傳之頭像圖檔儲存於 <code>Rails</code> public/uploads</li>
<li>備份檔案上傳至 <code>Amazon S3</code></li>
</ol>


<h4>安裝</h4>

<p><code>gem install backup</code></p>

<h4>範例</h4>

<p>打開空檔案即可使用</p>

<p>```ruby backup_config.rb
Backup::Model.new(:my_app, 'db data of my app') do
  # mysql 備份
  database MySQL do |db|</p>

<pre><code>db.name               = "my_app_db"
db.username           = "root"
db.password           = "12341234"
db.host               = "127.0.0.1"
db.port               = 3306
db.socket             = "/tmp/mysql.sock"
</code></pre>

<p>  end</p>

<p>  # user 頭像檔案<br/>
  archive :uploads do |archive|</p>

<pre><code>archive.add "/path/to/my_app/public/uploads"
</code></pre>

<p>  end</p>

<p>  # 上傳至 S3<br/>
  store_with S3 do |s3|</p>

<pre><code>s3.access_key_id      = "12341234"
s3.secret_access_key  = "!@#$%^&amp;*("
s3.region             = "us-east-1"
s3.bucket             = "my_app_backup"
s3.path               = '/'
s3.keep               = 50
</code></pre>

<p>  end</p>

<p>  # 壓縮打包設定
  compress_with Gzip do |compression|</p>

<pre><code>compression.best = true
compression.fast = false
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>執行</p>

<p><code>ruby
backup perform -t my_app -c backup_config.rb
</code></p>

<p>就可進行備份</p>

<p>若要做 <code>Rails</code> 定期備份, 再將指令整合於 <code>whenever</code> 即可<br/>
另外再提供儲存於 local disk 的範例</p>

<p>```ruby backup_config.rb
  store_with Local do |local|</p>

<pre><code>local.path = "/path/to/back/dir"
local.keep = 50
</code></pre>

<p>  end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rspec 設定 request 或 controller 的 spec 中 render view]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-03-06/rspec-render-views/"/>
    <updated>2012-03-06T11:05:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-03-06/rspec-render-views</id>
    <content type="html"><![CDATA[<p><code>rspec rails</code> 中預設是不會 render view 的, 因此 <code>response.body</code> 的內容會是空字串</p>

<!-- more -->


<p>為了讓 response.body 能實際的把 view render 出來, 可以有個別或預設的作法</p>

<p>個別</p>

<p>```ruby
describe UsersController do
  render_views
  it "GET #index" do</p>

<pre><code>get :index
response.body.should match("foo")
</code></pre>

<p>  end
end
```</p>

<p>預設</p>

<p><code>ruby spec/spec_helper.rb
RSpec.configure do |config|
  ....
  config.render_views
  ....
end
</code></p>

<p>小弟個人較偏好每個 request / controller 的 spec 都要 render_view<br/>
一方面可以檢驗 view 的正確性<br/>
若 view 中有使用 helper method, 也可以順便檢驗</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Factory Girl 的回呼 (callbacks)]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-02-29/factory-girl-callbacks/"/>
    <updated>2012-02-29T10:18:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-02-29/factory-girl-callbacks</id>
    <content type="html"><![CDATA[<p>在寫測試中, 有許多的情境, 可能會需要在產生測試用資料後做許多處理, 因此 <code>Factory Girl</code> 本身也提供了 <code>callback</code> 機制...</p>

<!-- more -->


<p>```ruby
FactoryGirl.define do
  factory :user do</p>

<pre><code>sequence(:email) { |n| "foo#{n}@bar.com" }
name "barbar"
password "12341234"
after_create do |user|
  # callback code block here
end
</code></pre>

<p>  end
end
```</p>

<p>詳細使用方式可見 <a href="https://github.com/thoughtbot/factory_girl/blob/master/GETTING_STARTED.md" target="_blank">官方說明文件</a></p>
]]></content>
  </entry>
  
</feed>
