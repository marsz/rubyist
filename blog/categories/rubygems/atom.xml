<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rubygems | 黃金俠]]></title>
  <link href="http://rubyist.marsz.tw/blog/categories/rubygems/atom.xml" rel="self"/>
  <link href="http://rubyist.marsz.tw/"/>
  <updated>2012-02-04T16:40:34+08:00</updated>
  <id>http://rubyist.marsz.tw/</id>
  <author>
    <name><![CDATA[MarsZ]]></name>
    <email><![CDATA[marsz330@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails Rspec (3) pending 的使用]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-02-03/rails-rspec-pending/"/>
    <updated>2012-02-03T16:06:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-02-03/rails-rspec-pending</id>
    <content type="html"><![CDATA[<p>pending 的使用可先參考 <a href="https://github.com/dchelimsky/rspec/wiki/Pending-Examples" target="_blank">官方文件</a><br/>
一般 generator 產生的 spec 檔都會先幫你把 pending 加好</p>

<!-- more -->


<p><code>ruby
describe Foo do
  pending "add some examples to (or delete) #{__FILE__}"
end
</code></p>

<p>如此便可在你跑 spec 後, 顯示有幾個 pending 尚未實作</p>

<p><code>
1 example, 0 failures, 1 pending
</code></p>

<p>因為不是每個專案都會讓你有時間寫 spec<br/>
等到有時間寫的時候, 可能會因為累積了太多而不知該從何寫起<br/>
所以 pending 的功用可讓你在未來能透過 pending 的麵包屑回頭逐一把 spec 補上</p>

<p>因此無論再怎麼趕怎麼忙, 也必須先將 pending 寫上</p>

<p>pending 可分幾個層次如下...</p>

<h4>整個 class 的 pending</h4>

<p>用於 lib class 較多, 當然遇到超趕的時候 controller, model 也都會整個 pending ~ XD</p>

<p><code>ruby
describe FoosController do
  pending
end
</code></p>

<h4>某個 method 的 pending</h4>

<p>新加的 method, 或 method 改寫了, 原先的 spec 不敷使用</p>

<p>```ruby
describe Foo do
  describe "#bar" do</p>

<pre><code>pending
</code></pre>

<p>  end
end
```</p>

<p>或</p>

<p><code>ruby
describe Foo do
  pending "#bar"
end
</code></p>

<p>一般都是後者的寫法</p>

<h4>method/action 內的某個 case</h4>

<p>針對單一 method/action 寫測試, test case 數通常取決於有多少 if else 在裡頭, 當然遇到比較特殊的 method/action 時, 可能也會有幾個 test case 是為預期錯誤而做的</p>

<p>```ruby
describe Foo do
  describe "#bar" do</p>

<pre><code>it "should be a kind of Bar" do
  ....
end
pending "should raise error if bar_id is nil"
</code></pre>

<p>  end
end
```</p>

<p>此外 method 只針對 public methods 寫<br/>
嚴謹的專案, 對於 model 的 association, validation, callbacks, scope 也都會寫對應的 spec<br/>
此外我的習慣是, 在每次 commit 前檢查本此修改是否需要補 spec 或 pending, 補完後才一起 commit</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Rspec (2) 基本語法與執行]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-02-02/rails-rspec-basic-syntax/"/>
    <updated>2012-02-02T14:35:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-02-02/rails-rspec-basic-syntax</id>
    <content type="html"><![CDATA[<p>建議在開始本系列文以前先讀過, 以下參考文件與資源</p>

<!-- more -->


<p><a href="http://www.slideshare.net/ihower/rspec-7394497" target="_blank">ihower 投影片</a> - 必看!!!!!<br/>
<a href="http://rubydoc.info/gems/rspec-core/2.8.0/file/README.md#" target="_blank">Rspec-core Rdoc</a> - 架構必看!!!<br/>
<a href="https://github.com/rspec/rspec-rails" target="_blank">Rspec Rails</a> - 官方提供的簡單範例 for models, controllers, routes, helpers 等</p>

<h4>describe 與 it + should</h4>

<p>最簡單的 rspec 可由 describe 和 it 組成<br/>
it 裡面必須有 should (或其他 match 語法) 才會構成測試</p>

<p>小弟在初學 rspec 的時候, 大多透過 should == 和 should_not == 就吃遍天下了 :p<br/>
一般在初學 rspec 時, 需要多注意 describe 和 it 的階層關係, 才會讓你的 spec 可讀性較高</p>

<p>有規劃的 spec</p>

<p>```ruby
describe Foo do
  describe "#get_bar" do</p>

<pre><code>it "should be nil" do
  Foo.new.get_bar.should == nil
end
it "should be Bar" do
  Foo.first.get_bar.class.should == Bar
end
</code></pre>

<p>  end
```</p>

<p>沒有規劃的 spec</p>

<p>```ruby
describe Foo do
  it "#get_bar" do</p>

<pre><code>Foo.new.get_bar.should == nil # 當這行的測試沒過時, 下面的測試便不會再執行
Foo.first.get_bar.class.should == Bar
</code></pre>

<p>  end
end
```</p>

<p>盡可能讓每個 it 都是針對一種結果進行測試<br/>
描述中用 # 開頭的就表示是 method name</p>

<p>當漸漸學會其他的 match 語法時, 可讀性就去更高了
例如 <a href="http://apidock.com/rspec/Spec/Matchers/be_a_kind_of" target="_blank">be_a_kind_of</a> 可用於做 is_a_kind_of 的 match</p>

<p><code>ruby
Foo.first.get_bar.should be_a_kind_of(Bar)
</code></p>

<p>相當於</p>

<p><code>ruby
Foo.first.get_bar.class.should == Bar
</code></p>

<p>前者的可讀性是比較高的</p>

<h4>before 與 it</h4>

<p>before 必定是在某個 describe 下, 而 before 內的行為會在每個 it 以前執行<br/>
而善用 instance 變數, 可以將 before 產生的變數傳遞給底下每個 it 用</p>

<p>```ruby
describe Foo do
  before do</p>

<pre><code>@foo = Foo.create!
</code></pre>

<p>  end
  describe "#bar" do</p>

<pre><code>before do
  @bar = Bar.create!
  @foo.bar = @bar
  @foo.save
end
it "should be Bar" do
   @foo.bar.should be_a_kind_of(Bar) # 可以拿到 @foo
end
it "should be equeal to @bar" do
   @foo.bar.id.should == @bar.id # 也可以拿到 @bar
end
</code></pre>

<p>  end
  it "be a kind of Foo" do</p>

<pre><code>@foo.should be_a_kind_of(Foo) # 只能拿到 @foo
</code></pre>

<p>  end
end
```</p>

<p>此外每個 it 結束後, 都會將此 it (含 before) 內對 test db 的修改通通 rollback, 因此我們可視為每個 it 執行前 (before 前), test db 都會是空的</p>

<h4>執行測試</h4>

<p>必須注意:</p>

<ol>
<li>config/database.yml 必須要有 test env 的設定, 且 database 不能和 migrate 一樣</li>
<li>執行前若 development 有 migrations 沒跑的話, 必須先跑完</li>
</ol>


<p>跑 spec/ 下的所有測試</p>

<p><code>
bundle exec rake spec
</code></p>

<p>跑單一檔案的 spec</p>

<p><code>
bundle exec rspec spec/models/foo_spec.rb
</code></p>

<p>跑單一檔案時, 不會先重新 load db schema, 因此若有新的 migrations 在 development 跑過後, 必須先 rake spec 後才能跑單一檔案的 rspec</p>

<p>更多 rspec 指令的應用</p>

<p><code>
bundle exec rspec -h
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Rspec (1) 介紹與設定]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-02-01/rails-rspec-intro-and-setup/"/>
    <updated>2012-02-01T14:00:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-02-01/rails-rspec-intro-and-setup</id>
    <content type="html"><![CDATA[<p>有關寫測試的重要性, 本文不再贅述<br/>
觀念性文章可參考以下大大們的見解...</p>

<!-- more -->


<p><a href="http://mrjamie.cc/2011/09/01/test-code/" target="_blank">Coding: 寫 Test 還是不寫 Test?</a> - Mr. Jamie<br/>
<a href="http://ihower.tw/rails3/testing.html" target="_blank">Rails 3 實戰聖經: 測試 Testing</a> - ihower<br/>
<a href="http://www.slideshare.net/ihower/rspec-7394497?from=ss_embed">Rspec 讓你愛上寫測試</a> - ihower</p>

<h5>安裝</h5>

<p>參考官方文件: <a href="https://github.com/rspec/rspec-rails" target="_blank">https://github.com/rspec/rspec-rails</a></p>

<p>Gemfile</p>

<p><code>ruby
group :test, :development do
  gem "rspec"
  gem "rspec-rails"
  gem "factory_girl_rails" # 用於產生資料, 後面的文章將會介紹
  gem "shoulda-matchers" # 用於簡化寫 rspec 的工具, 後面的文章將會介紹
end
</code></p>

<p><code>
bundle install
</code></p>

<p>產生檔案</p>

<p><code>
rails generate rspec:install
</code></p>

<p>移除舊的 test, 可視需求執行, 一般有了 rspec 就不會想再用舊的 test 框架啦 XD</p>

<p><code>
rm -rf test/
</code></p>

<p>此時專案下會多了 spec 目錄, 以及 spec/spec_helper.rb<br/>
另外透過 rails g 產生 model 或 controller 時, spec 目錄下也會產生對應的 spec 檔<br/>
如</p>

<p>```
rails g model foo</p>

<p>```</p>

<p>```</p>

<pre><code>  invoke  active_record
  create    db/migrate/20120204063026_create_foos.rb
  create    app/models/foo.rb
  invoke    rspec
  create      spec/models/foo_spec.rb
</code></pre>

<p>```</p>

<p>同理, rails destroy 也會對應刪除</p>

<p>下一篇將會介紹基本語法以及跑測試的方法</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的 capistrano 完整設定檔說明]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-01-14/my-capistrano-config-with-multistage-apache-restart-assets-precompile-and-symlink-shared/"/>
    <updated>2012-01-14T16:09:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-01-14/my-capistrano-config-with-multistage-apache-restart-assets-precompile-and-symlink-shared</id>
    <content type="html"><![CDATA[<p>capistrano 是一套強大的佈署工具, 今天提供小弟的設定檔內容給大家參考</p>

<!-- more -->


<p>rvm 和 bundler</p>

<p><code>ruby config/deploy.rb
$:.unshift(File.expand_path('./lib', ENV['rvm_path'])) # Add RVM's lib directory to the load path.
require "rvm/capistrano" # Load RVM's capistrano plugin.
require 'bundler/capistrano'
</code></p>

<p>capistrano color, 讓佈署過程中的訊息內容上色<br/>
Gemfile 必須先加上 gem 'capistrano_colors'</p>

<p><code>ruby config/deploy.rb
begin
  require 'capistrano_colors'
rescue LoadError
  puts "`gem install capistrano_colors` to get output more userfriendly."
end
</code></p>

<p>cron 設定, 透過 whenever gem 在 deploy 時, 更新 cron<br/>
Gemfile 要有 gem 'whenever'</p>

<p><code>ruby config/deploy.rb
require "whenever/capistrano"
</code></p>

<p>multistages 設定, 讓 server 端的設定和佈署工作各自獨立管理, 同時資源佈署多個 server</p>

<p><code>ruby config/deploy.rb
require 'capistrano/ext/multistage'
set :stages,        %w(staging production)
set :default_stage, "staging"
</code></p>

<p>基本設定, 包含 git</p>

<p>```ruby config/deploy.rb
set :application, "foo"
set :repository,  "git@github.com:marsz/foo.git"</p>

<p>set :scm, :git</p>

<p>set :use_sudo, false
```</p>

<p>設定 deploy:restart, capistrano 預設是空的, 所以重起 rack 的部份一定要自己寫, 以下範例以 <a href="http://www.modrails.com/documentation/Users%20guide%20Apache.html#_redeploying_restarting_the_ruby_on_rails_application" target="_blank">passenger + apache</a> 的重啟方式做為參考</p>

<p>```ruby config/deploy.rb</p>

<h1>namespace :deploy 內</h1>

<p>namespace :deploy do
  # .....
  task :restart, :roles => :app, :except => { :no_release => true } do</p>

<pre><code>run "touch #{current_path}/tmp/restart.txt"
</code></pre>

<p>  end
  # .....
end
```</p>

<p>設定 symlink_shared, 有一些沒進 version control 的 config 檔案, 要在佈署時, link 過去, 例如 config/database.yml, 以下僅供參考, 實際 link 內容須自己寫</p>

<p>```ruby config/deploy.rb</p>

<h1>namespace :deploy 內</h1>

<p>namespace :deploy
  # ....
  task :symlink_shared, :roles => [:app] do</p>

<pre><code>config_files = [:database, :redis]
symlink_hash = {}
config_files.each do |fname|
  from = "#{shared_path}/config/#{fname}.yml"
  to = "#{release_path}/config/#{fname}.yml"
  run "ln -s #{from} #{to}"
end
</code></pre>

<p>  end
  # ....
end</p>

<h1>把 symlink_shared 內容掛進去 deploy 中</h1>

<p>before "bundle:install", "deploy:symlink_shared"
```</p>

<p>tail log, 要線上 debug 時可用</p>

<p>```ruby config/deploy.rb
task :tail_log, :roles => :app do
  run "tail -f -n 100 #{shared_path}/log/#{rails_env}.log"
end</p>

<h1>執行 cap production tail_log 即可</h1>

<p>```</p>

<p>使用了 multistage 後, 各個 server 的設定檔必須放在 config/deploy/ 下, 檔名對應 stage 名稱<br/>
例如 config/deploy/production.rb
以下為 stage 設定檔內容</p>

<p>預設 rails env</p>

<p><code>ruby config/deploy/production.rb
set :rails_env, "production"
</code></p>

<p>github 分支</p>

<p><code>ruby config/deploy/production.rb
set :branch, 'master'
</code></p>

<p>ssh 登入相關, 建議多利用 <a href="http://www.eng.cam.ac.uk/help/jpmg/ssh/authorized_keys_howto.html" target="_blank"> SSH 免密碼登入 </a></p>

<p><code>ruby config/deploy/production.rb
set :user, 'marsz'
set :domain, 'xxx.com'
server "#{domain}", :web, :app, :db, :primary =&gt; true
</code></p>

<p>佈署的 dir path</p>

<p><code>ruby config/deploy/production.rb
set :deploy_to, "/path/to/app"
</code></p>

<p>佈署指令</p>

<p><code>
cap production setup # 第一次佈署環境建立
cap production deploy # 進行佈署
cap production deploy:migrations # 進行佈署並且跑 migration
</code></p>

<p>若想要在 cap deploy 時也執行 rake assets:precompile<br/>
可以參考 <a href="http://rubyist.marsz.tw/blog/2011-12-25/assets-precompile-in-capistrano-deploy/" target="_blank">這篇</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Carrierwave 處理檔案上傳 (整合 imagemagick 與 Amazon S3)]]></title>
    <link href="http://rubyist.marsz.tw/blog/2012-01-10/carrierwave-guides-with-amazon-s3-and-imagemagick-integration/"/>
    <updated>2012-01-10T23:38:00+08:00</updated>
    <id>http://rubyist.marsz.tw/blog/2012-01-10/carrierwave-guides-with-amazon-s3-and-imagemagick-integration</id>
    <content type="html"><![CDATA[<h2>參考來源</h2>

<ul>
<li>Github <a href="https://github.com/jnicklas/carrierwave">https://github.com/jnicklas/carrierwave</a></li>
</ul>


<!-- more -->


<h2>安裝</h2>

<p>```ruby Gemfile</p>

<pre><code>gem 'carrierwave'
</code></pre>

<p>```</p>

<h2>建立 uploader</h2>

<pre><code>rails generate uploader user_avatar
</code></pre>

<p>檔案產生於</p>

<pre><code>app/uploader/user_avatar_uploader.rb
</code></pre>

<h2>簡易範例</h2>

<h4>直接使用</h4>

<p>```ruby</p>

<pre><code>uploader = UserAvatarUploader.new
uploader.store!(my_file)
</code></pre>

<p>```</p>

<h4>掛在 model 裡使用</h4>

<p>在 model 裡
```ruby app/models/user.rb</p>

<pre><code>class User
  mount_uploader :picture, UserAvatarUploader
end
</code></pre>

<p>```</p>

<p>新增 migration, 因欄位名稱是 picture, 所以新增一個 picture 的 string 欄位在 users table 裡</p>

<pre><code>rails g migration add_column_picture_to_users
</code></pre>

<p>```ruby db/migrate/201101011213_add_column_picture_to_users.rb</p>

<pre><code>add_column :users, :picture, :string
</code></pre>

<p>```</p>

<p>```html _form.html.erb</p>

<pre><code>&lt;input type="file" name="picture" /&gt;
</code></pre>

<p>```</p>

<p>```ruby users_controller.rb</p>

<pre><code>u = User.new
u.picture = params[:picture]
u.save!
u.picture.url # =&gt; /url/to/file.png
</code></pre>

<p>```</p>

<p>在 _form.html.erb 送出 post 後, 便會按照在 user_avatar_uploader.rb 中的設定進行儲存並且回傳檔案>網址</p>

<h2>uploader 設定</h2>

<h4>儲存</h4>

<p>存成檔案, fog  為將檔案上傳至 cdn 用, 稍後會介紹
```ruby app/uploader/user_avatar_uploader.rb</p>

<pre><code>storage :file
# storage :fog
</code></pre>

<p><code>
可覆寫 store_dir, 以指定儲存路徑, 以 public/ 為基礎
</code>ruby app/uploader/user_avatar_uploader.rb</p>

<pre><code>def store_dir
   "uploader/user_avatar"
end
</code></pre>

<p><code>
限定檔案附檔名
</code>ruby app/uploader/user_avatar_uploader.rb</p>

<pre><code>def extension_white_list
  %w(jpg jpeg gif png)
end
</code></pre>

<p><code>
指定檔名, 包含附檔名 (model.id 稍後介紹)
</code>ruby app/uploader/user_avatar_uploader.rb</p>

<pre><code>def filename
  # @filename
  "#{model.id}.png"
end
</code></pre>

<p><code>
指定預設的 url (e.g.沒有圖的時候)
</code>ruby app/uploader/user_avatar_uploader.rb</p>

<pre><code>def default_url
  "/images/fallback/" + [version_name, "default.png"].compact.join('_')
end
</code></pre>

<p>```</p>

<h4>使用 Imagemagick 壓縮</h4>

<p>Gemfile
```ruby Gemfile</p>

<pre><code>gem 'rmagick'
</code></pre>

<p><code>
uploader 加上
</code>ruby app/uploader/user_avatar_uploader.rb</p>

<pre><code>include CarrierWave::RMagick
</code></pre>

<p><code>
在 user_avatar_uploader.rb 中可以自行定義要用哪些 Imagemagick 的 method 處理圖片
</code>ruby app/uploader/user_avatar_uploader.rb</p>

<pre><code># 轉換成 png
process :convert =&gt; 'png'
# 按比例縮成指定大小並且補白
process :resize_and_pad =&gt; [160, 160]
</code></pre>

<p>```
所有可用的 api 見 <a href="https://github.com/jnicklas/carrierwave/blob/master/lib/carrierwave/processing/rmagick.rb">https://github.com/jnicklas/carrierwave/blob/master/lib/carrierwave/processing/rmagick.rb</a></p>

<p>若希望可以另做縮圖, 可以透過 version 同時建立與原圖不同的版本
```ruby app/uploader/user_avatar_uploader.rb</p>

<pre><code># 版本名稱為 thumb
version :thumb do
   process :resize_and_pad =&gt; [100, 100]
   process :convert =&gt; 'png'
end
# 版本名稱為 small
version :small do
   process :resize_and_pad =&gt; [160, 160]
   process :convert =&gt; 'png'
end
</code></pre>

<p>```</p>

<p>mixin 類似 CarrierWave::RMagick 的 module 可以將更多 RMagick 的 api 應用在 process 中</p>

<p>RMagick api 可參考</p>

<blockquote><ul>
<li>doc: <a href="http://studio.imagemagick.org/RMagick/doc/">http://studio.imagemagick.org/RMagick/doc/</a></li>
<li>source: <a href="https://github.com/rmagick/rmagick/blob/master/lib/RMagick.rb">https://github.com/rmagick/rmagick/blob/master/lib/RMagick.rb</a></li>
</ul>
</blockquote>

<p>取得 version :
```ruby</p>

<pre><code>u = User.find(1)
u.picture.url # 原圖 url
u.picture.thumb.url # thumb 版本的 url
u.picture.small.url # small 版本的 url
</code></pre>

<p>```</p>

<h4>上傳至 CDN (以 Amazon S3 為例)</h4>

<p>```ruby Gemfile</p>

<pre><code>gem 'fog'
</code></pre>

<p><code>
在 storage 改為 fog
</code>ruby app/uploader/user_avatar_uploader.rb</p>

<pre><code>storage :fog
</code></pre>

<p><code>
新增 config/initializer/carrierwave.rb, 內容如下
</code>ruby config/initializer/carrierwave.rb</p>

<pre><code>CarrierWave.configure do |config|
  config.fog_credentials = {
    :provider               =&gt; 'AWS',       # required
    :aws_access_key_id      =&gt; 'XXXXX',       # your aws access key id
    :aws_secret_access_key  =&gt; 'xxxxxxxxxx',       # your aws secret access key
    :region                 =&gt; 'ap-southeast-1'  # your bucket's region in S3, defaults to 'us-east-1'
  }
  # your S3 bucket name
  config.fog_directory  = 'my_bucket'
  # custome your domain on aws S3, defaults to nil
  config.fog_host       = 'http://myapp.com'
  config.fog_public     = true                                   # optional, defaults to true
  config.fog_attributes = {'Cache-Control'=&gt;'max-age=315576000'}  # optional, defaults to {}
end
</code></pre>

<p>```
依上述範例, 要在 S3 開一個 public bucket 名為 "my_bucket", 地區為新加坡</p>

<p>access key 可至 <a href="https://aws-portal.amazon.com/gp/aws/developer/account/index.html?action=access-key">https://aws-portal.amazon.com/gp/aws/developer/account/index.html?action=access-key</a> 搜尋</p>

<p>bucket 中儲存的路徑可在 user_avatar_uploader.rb 中的 store_dir 定義
```ruby app/uploader/user_avatar_uploader.rb</p>

<pre><code>def store_dir
    "user_avatar/#{model.id}"
end
</code></pre>

<p>```</p>

<h4>uploader 的 methods</h4>

<p>當你將 uploader mount 進 model, 就可以在 uploader 中直接取得該 model 的 instance
```ruby app/uploader/user_avatar_uploader.rb</p>

<pre><code>def filename
   "#{model.id}.png"
end
# and mounted_as
def store_dir
   "uploader/user_avatar/#{mounted_as}"
end
</code></pre>

<p>```
uploader 有哪些 medthods 可參考 <a href="https://github.com/jnicklas/carrierwave/tree/master/lib/carrierwave/uploader">https://github.com/jnicklas/carrierwave/tree/master/lib/carrierwave/uploader</a></p>

<h4>處理 local file 或 remote file</h4>

<p>remote file, 參考 <a href="http://stackoverflow.com/questions/5007575/how-to-assign-a-remote-file-to-carrierwave">http://stackoverflow.com/questions/5007575/how-to-assign-a-remote-file-to-carrierwave</a>
```ruby</p>

<pre><code>u = User.find(1)
url = "http://www.google.com/logo.png"
u.remote_picture_url = url
u.save
</code></pre>

<p><code>
local file
</code>ruby</p>

<pre><code>u =  User.find(1)
file_path = "#{Rails.root}/public/images/exmaples/foo.png"
u.picture = File.open(file_path)
</code></pre>

<p>```</p>

<p>Carrierwave 的特色在於細節定義都在 uploader 中, 而 model 只要 mount 以及加上 string 欄位即可</p>
]]></content>
  </entry>
  
</feed>
